{"version":3,"file":"config.js","mappings":"mBACAA,KAAKC,eAAiB,CAClBC,KAAM,GAAGC,SAASC,eAClBC,OAAQ,WACRC,MCJgB,CAChBC,OAAQ,CAACC,EAAM,KAAOA,EACtBC,OAAQ,CAACD,EAAM,KAAOA,GDGtBE,MAAO,CACHC,OAAQ,oBACRC,OAAQ,oBACRC,GAAI,iBAERC,UAAW,CACP,wBACA,2BAGOd,KAAmB,c","sources":["webpack://osana/./src/config.ts","webpack://osana/./src/lib/util/codecs.ts"],"sourcesContent":["import * as codecs from \"./lib/util/codecs\";\r\nself.__osana$config = {\r\n    bare: `${location.origin}/bare/`,\r\n    prefix: \"/~osana/\",\r\n    codec: codecs.none,\r\n    files: {\r\n        config: \"/~osana/config.js\",\r\n        client: \"/~osana/client.js\",\r\n        sw: \"/~osana/sw.js\"\r\n    },\r\n    blacklist: [\r\n        /^(www\\.)?netflix\\.com/,\r\n        /^accounts\\.google\\.com/,\r\n    ]\r\n};\r\nexport default self.__osana$config;\r\n","export const none = {\r\n    encode: (url = \"\") => url,\r\n    decode: (url = \"\") => url\r\n};\r\nexport const plain = {\r\n    encode: (url = \"\") => encodeURIComponent(url),\r\n    decode: (url = \"\") => decodeURIComponent(url)\r\n};\r\nexport const xor = {\r\n    encode: (url = \"\") => {\r\n        return encodeURIComponent(url.toString().split(\"\").map((char, ind) => ind % 2 ? String.fromCharCode(char.charCodeAt(0) ^ 2) : char).join(\"\"));\r\n    },\r\n    decode: (url = \"\") => {\r\n        let [input, ...search] = url.split(\"?\");\r\n        return decodeURIComponent(input).split(\"\").map((char, ind) => ind % 2 ? String.fromCharCode(char.charCodeAt(0) ^ 2) : char).join(\"\") + (search.length ? \"?\" + search.join(\"?\") : \"\");\r\n    }\r\n};\r\nexport const base64 = {\r\n    encode: (url) => {\r\n        const TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n        url = String(url);\r\n        if (/[^\\0-\\xFF]/.test(url))\r\n            new DOMException(\"The string to be encoded contains characters outside of the Latin1 range.\");\r\n        let padding = url.length % 3, output = \"\", position = -1, a, b, c, buffer, length = url.length - padding;\r\n        while (++position < length) {\r\n            a = url.charCodeAt(position) << 16;\r\n            b = url.charCodeAt(++position) << 8;\r\n            c = url.charCodeAt(++position);\r\n            buffer = a + b + c;\r\n            output += (TABLE.charAt(buffer >> 18 & 0x3F) + TABLE.charAt(buffer >> 12 & 0x3F) + TABLE.charAt(buffer >> 6 & 0x3F) + TABLE.charAt(buffer & 0x3F));\r\n        }\r\n        if (padding == 2) {\r\n            a = url.charCodeAt(position) << 8;\r\n            b = url.charCodeAt(++position);\r\n            buffer = a + b;\r\n            output += (TABLE.charAt(buffer >> 10) + TABLE.charAt((buffer >> 4) & 0x3F) + TABLE.charAt((buffer << 2) & 0x3F) + \"=\");\r\n        }\r\n        else if (padding == 1) {\r\n            buffer = url.charCodeAt(position);\r\n            output += (TABLE.charAt(buffer >> 2) + TABLE.charAt((buffer << 4) & 0x3F) + \"==\");\r\n        }\r\n        return output;\r\n    },\r\n    decode: (url) => {\r\n        const TABLE = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\r\n        url = String(url).replace(/[\\t\\n\\f\\r ]/g, \"\");\r\n        var length = url.length;\r\n        if (length % 4 == 0) {\r\n            url = url.replace(/==?$/, \"\");\r\n            length = url.length;\r\n        }\r\n        ;\r\n        if (length % 4 == 1 || /[^+a-zA-Z0-9/]/.test(url))\r\n            throw new DOMException(\"Failed to execute 'atob' on 'Window': The string to be decoded is not correctly encoded.\");\r\n        let bitCounter = 0, bitStorage, buffer, output = \"\", position = -1;\r\n        while (++position < length) {\r\n            buffer = TABLE.indexOf(url.charAt(position));\r\n            bitStorage = bitCounter % 4 ? bitStorage * 64 + buffer : buffer;\r\n            if (bitCounter++ % 4)\r\n                output += String.fromCharCode(0xFF & bitStorage >> (-2 * bitCounter & 6));\r\n        }\r\n        return output;\r\n    }\r\n};\r\nexport const whatTheFuck = {\r\n    decode: (string) => {\r\n        const charShiftLength = parseInt(string.substring(0, 2));\r\n        const charShiftData = parseInt(string.substring(2, charShiftLength + 2));\r\n        const str = decodeURIComponent(string.substring(charShiftLength + 2, string.length));\r\n        const sections = str.match(new RegExp(`.{1,${charShiftLength}}`, \"g\"));\r\n        let out = \"\";\r\n        for (let i in sections)\r\n            for (let j in sections[i].split(\"\"))\r\n                out += String.fromCharCode(sections[i][j].charCodeAt(0) - parseInt(charShiftData.toString()[j]));\r\n        return decodeURIComponent(out);\r\n    },\r\n    encode: (string) => {\r\n        const charShiftLength = Math.ceil(Math.random() * 10);\r\n        const charShiftData = (n => { let out = \"\"; for (let i = 0; i < n; i++)\r\n            out += Math.ceil(Math.random() * 9); return parseInt(out); })(charShiftLength);\r\n        const str = encodeURIComponent(string);\r\n        const sections = str.match(new RegExp(`.{1,${charShiftLength}}`, \"g\"));\r\n        let out = \"\";\r\n        for (let i in sections)\r\n            for (let j in sections[i].split(\"\"))\r\n                out += String.fromCharCode(sections[i][j].charCodeAt(0) + parseInt(charShiftData.toString()[j]));\r\n        return encodeURIComponent(`${charShiftLength < 10 ? `0${charShiftLength}` : charShiftLength}${charShiftData}${out}`);\r\n    }\r\n};\r\n"],"names":["self","__osana$config","bare","location","origin","prefix","codec","encode","url","decode","files","config","client","sw","blacklist"],"sourceRoot":""}